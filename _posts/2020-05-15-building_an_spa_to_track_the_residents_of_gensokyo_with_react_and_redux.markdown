---
layout: post
title:      "Building an SPA to track the residents of Gensokyo with React and Redux"
date:       2020-05-15 20:56:18 +0000
permalink:  building_an_spa_to_track_the_residents_of_gensokyo_with_react_and_redux
---


For my final project, the React-Redux project, I've decided to build a single page application where the user can create, read, update, and destroy information about characters, their appearances, their spellcards, and the games from the Touhou Project serires of video games.

I started first by sketching out what data each model should keep track of and how it should relate to the other models. Once I figured that out, I started by creating the rails backend of my app with ```rails new (name) --api``` and scaffolding out the models with all the appropriate data. After that, I added validations on the models so that the database wouldn't accept any invalid data (I actually had to build a custom validator for my Appearance model; if the playable value is false, the stage value must have content and if playable is true the stage value must be empty). Then, I created serializers for my Game and Character models so that when I fetched them their JSON would render the way I wanted to. Sidenote: I also added in ```rack-cors```, so that my fetch requests could actually go through, and I edited the ```puma.rb``` file so that the rails server would get hosted on ```localhost:3001``` rather than ```localhost:3000``` since it latter was already being used to host the frontend. Finally, I created some test data to seed my database with just to make sure it was functioning the way I expected it to, and with that success it was on to the frontend.

I began to build my frontend by first using ```create-react-app (name)``` to get the basic structure and following it up with ```yarn add redux```, ```yarn add react-redux```, and  ```yarn add react-router-dom``` to allow my app to have a store, to let my components connect to the store, and to allow my page to have multiple routes, respectively. Next, I created a simple text only homepage, ```components/Home.js``` to greet the user and direct them towards the rest of the content. Then, via the use of ```components/Navbar.js```, the user can go to the characters index, the new character form, the games index, or the new game form. Starting from the less complex side, ```components/CharacterForm.js``` and ```components/GameForm.js```, which belong under ```containers/CharacterContainer.js``` and ```containers/GameContainer.js```, are passed a ```newCharacter``` or ```newGame``` prop to indicate whether the user is accessing the form via the navbar, indicating that they wish to create a new character rather than edit an existing one, and they are also passed an ```initialCharacter``` or ```initialGame``` object which is then spread into their state in order to obtain the correct structure or to populate the fields with existing data if the user is editing rather than creating. From there, the form in question is a controlled form such that the value of a field on the form is tied the corresponding field in the state, which updates whenever the user makes a change to one of the text fields. When the user submits the form, the app will check it's ```newCharacter``` or ```newGame``` boolean to see if it should call the ```createCharacter``` or ```createGame``` function in ```actions/character.js``` or ```actions/game.js``` or the ```patchCharacter``` or ```patchGame``` function located in the same place and after the fetch request resolves, if the response has no errors, the user will be redirected to the appropriate index, ```/characters``` or ```/games```, and the state of the form cleared if they created a new character or game, or, if the user was editing an existing character or game, the form recollapsed. If the response did have errors, the user is alerted to the errors and the corresponding fields of the form are highlighted in red.

Next are the character and game indecies. Since games have fewer relationships, let's talk about their index and individual pages first. Firstly, on the game index ```/games```, the user can select how, if at all, they would like to sort the links to the individual games, either alphabetically, reverse alphabetically, or by what character appears in them (i.e. if character A appears in only game B and game C, only game B and C will be displayed if character A is selected). From there, the user can click on the name of a game to be taken to it's individual show page wherein all the data about that game is displayed (name, developer, publisher, release date, genre, story). Then, the user can click one of two buttons under the displayed data to either edit the game, which renders a ```GameForm``` with ```newGame``` set to false and the current game passed down to pre-fill fields. After that, the ```/games/:id``` page also renders all appearances associated with that game. Each appearance has an edit and delete button attached to it and beneath the last rendered appearance on the page, there exists a button to create a new appearance whose ```game_id```, or ```character_id```, value is immediately assigned as the parent is passed down as a prop. On the ```AppearanceForm```, the user is given a dropdown menu to select from existing characters or games, depending on which type of object the parent is, a text field to enter which stage the character was on, and another dropdown menu to indicate whether the character was playable or not. If the character was playable, the stage field is removed from the form and is set to an empty string in the state. Furthermore, the appearances are rendered with links to the show pages of its associated character and game. The character index has the same features as the game index, sorting wise. The character show page, while rendering content in much the same way as the game show page with the object's personal content at the top with an edit and delete button just below it and a list of appearances with their own associated buttons, characters have a list of their spellcards at the bottom of the page which also have their own edit and delete buttons, with a button to create new spellcards at the very bottom of the page.
